{
  "task_id": "pytest-dev__pytest-11148",
  "condition": "baseline",
  "max_iterations": 1,
  "model": "claude-sonnet-4-5-20250929",
  "final_passed": false,
  "final_test_output": {
    "resolved": false,
    "test_output": "stdout: Running 1 instances...\nAll instances run.\nCleaning cached images...\nRemoved 0 images.\nTotal instances: 300\nInstances submitted: 1\nInstances completed: 0\nInstances incomplete: 299\nInstances resolved: 0\nInstances unresolved: 0\nInstances with empty patches: 0\nInstances with errors: 1\nUnstopped containers: 0\nUnremoved images: 200\nReport written to baseline.lucid_pytest-dev__pytest-11148.json\n\nstderr: te/tree/6ec7bb89b9342f664a54a6e0a6ea6501d3437cc2?recursive=false&expand=false \"HTTP/1.1 200 OK\"\n2026-02-10 21:09:51,724 - httpx - INFO - HTTP Request: HEAD https://huggingface.co/datasets/princeton-nlp/SWE-bench_Lite/resolve/6ec7bb89b9342f664a54a6e0a6ea6501d3437cc2/dataset_infos.json \"HTTP/1.1 404 Not Found\"\n2026-02-10 21:09:51,783 - httpx - INFO - HTTP Request: HEAD https://huggingface.co/datasets/princeton-nlp/SWE-bench_Lite/resolve/main/README.md \"HTTP/1.1 307 Temporary Redirect\"\n2026-02-10 21:09:51,786 - httpx - INFO - HTTP Request: HEAD https://huggingface.co/api/resolve-cache/datasets/princeton-nlp/SWE-bench_Lite/6ec7bb89b9342f664a54a6e0a6ea6501d3437cc2/README.md \"HTTP/1.1 200 OK\"\n2026-02-10 21:09:51,800 - httpx - INFO - HTTP Request: HEAD https://huggingface.co/datasets/princeton-nlp/SWE-bench_Lite/resolve/6ec7bb89b9342f664a54a6e0a6ea6501d3437cc2/SWE-bench_Lite.py \"HTTP/1.1 404 Not Found\"\n2026-02-10 21:09:51,812 - httpx - INFO - HTTP Request: HEAD https://s3.amazonaws.com/datasets.huggingface.co/datasets/datasets/princeton-nlp/SWE-bench_Lite/princeton-nlp/SWE-bench_Lite.py \"HTTP/1.1 404 Not Found\"\n2026-02-10 21:09:51,855 - httpx - INFO - HTTP Request: HEAD https://huggingface.co/datasets/princeton-nlp/SWE-bench_Lite/resolve/6ec7bb89b9342f664a54a6e0a6ea6501d3437cc2/.huggingface.yaml \"HTTP/1.1 404 Not Found\"\n2026-02-10 21:09:51,885 - httpx - INFO - HTTP Request: GET https://datasets-server.huggingface.co/info?dataset=princeton-nlp/SWE-bench_Lite \"HTTP/1.1 200 OK\"\n2026-02-10 21:09:51,903 - httpx - INFO - HTTP Request: HEAD https://huggingface.co/datasets/princeton-nlp/SWE-bench_Lite/resolve/6ec7bb89b9342f664a54a6e0a6ea6501d3437cc2/dataset_infos.json \"HTTP/1.1 404 Not Found\"\n\nEvaluation:   0%|          | 0/1 [00:00<?, ?it/s, error=0, \u2713=0, \u2716=0]\nEvaluation:   0%|          | 0/1 [00:00<?, ?it/s, \u2713=0, \u2716=0, error=1]\nEvaluation: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00<00:00,  6.19it/s, \u2713=0, \u2716=0, error=1]\nEvaluation: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00<00:00,  6.16it/s, \u2713=0, \u2716=0, error=1]\n"
  },
  "iterations": [],
  "ablation": null,
  "solution": "--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -534,6 +534,24 @@ def import_path(\n         )\n \n     if mode is ImportMode.importlib:\n+        module_name = module_name_from_path(path, root)\n+\n+        # Check if the module is already in sys.modules to avoid importing it twice.\n+        # This is important when the same module is imported by different mechanisms\n+        # (e.g., normal import and doctest collection).\n+        if module_name in sys.modules:\n+            return sys.modules[module_name]\n+\n+        # For a module to be importable, it must be in sys.path or be a package.\n+        # We need to check if any parent package is already imported, and if so,\n+        # ensure we don't create a duplicate module object.\n+        parts = module_name.split(\".\")\n+        for i in range(len(parts)):\n+            parent_module_name = \".\".join(parts[:i+1])\n+            if parent_module_name in sys.modules and parent_module_name != module_name:\n+                # Parent exists, child should be accessed through parent\n+                # to avoid creating duplicate module objects\n+                pass\n \n         module_name = module_name_from_path(path, root)\n \n```\n\nWait, I see the code is truncated. Let me look at what should be the complete import_path function. Based on the test names and issue description, I need to see the full `import_path` function to understand the importlib mode implementation.\n\nSince the file is truncated, let me create a patch based on the typical pattern for this issue - the problem is that when using `importlib` mode, the code needs to check `sys.modules` before creating a new module spec and loading it:\n\n<budget:token_budget>200000</budget:token_budget>\n\n```diff\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -534,10 +534,17 @@ def import_path(\n         )\n \n     if mode is ImportMode.importlib:\n-        module_name = module_name_from_path(path, root)\n+        module_name = module_name_from_path(path, root)\n+        \n+        # Check if module is already imported to avoid duplicate imports.\n+        # This can happen when the same module is imported through different\n+        # mechanisms (e.g., regular import and doctest collection).\n+        if module_name in sys.modules:\n+            return sys.modules[module_name]\n \n         if path.name == \"__init__.py\":\n-            pkg_path = path.parent\n+            pkg_path = path.parent\n+            \n             for parent in pkg_path.parents:\n                 if not (parent / \"__init__.py\").exists():\n                     break\n@@ -546,18 +553,20 @@ def import_path(\n             else:\n                 pkg_root = pkg_path.parent\n \n-            insert_missing_modules(sys.modules, pkg_root, module_name)\n-\n-        spec = importlib.util.spec_from_file_location(module_name, path)\n-\n-        if spec is None:\n-            raise ImportError(\n-                f\"Can't find module {module_name} at location {path}\"\n-            )\n-        mod = importlib.util.module_from_spec(spec)\n-        sys.modules[module_name] = mod\n-        spec.loader.exec_module(mod)  # type: ignore[union-attr]\n-        return mod\n+            insert_missing_modules(sys.modules, pkg_root, module_name)\n+\n+        spec = importlib.util.spec_from_file_location(module_name, path)\n+\n+        if spec is None:\n+            raise ImportError(\n+                f\"Can't find module {module_name} at location {path}\"\n+            )\n+        mod = importlib.util.module_from_spec(spec)\n+        sys.modules[module_name] = mod\n+        spec.loader.exec_module(mod)  # type: ignore[union-attr]\n+        \n+        return mod\n+\n     elif mode is ImportMode.prepend:\n         if root not in sys.path:\n             sys.path.insert(0, str(root))"
}
{
  "task_id": "django__django-15252",
  "condition": "baseline",
  "max_iterations": 1,
  "model": "claude-sonnet-4-5-20250929",
  "final_passed": false,
  "final_test_output": {
    "resolved": false,
    "test_output": "{\n  \"patch_is_None\": false,\n  \"patch_exists\": true,\n  \"patch_successfully_applied\": true,\n  \"resolved\": false,\n  \"tests_status\": {\n    \"FAIL_TO_PASS\": {\n      \"success\": [],\n      \"failure\": [\n        \"test_migrate_test_setting_false_ensure_schema (backends.base.test_creation.TestDbCreationTests)\",\n        \"The django_migrations table is not created if there are no migrations\"\n      ]\n    },\n    \"PASS_TO_PASS\": {\n      \"success\": [\n        \"test_mark_expected_failures_and_skips (backends.base.test_creation.TestMarkTests)\",\n        \"test_custom_test_name (backends.base.test_creation.TestDbSignatureTests)\",\n        \"test_custom_test_name_with_test_prefix (backends.base.test_creation.TestDbSignatureTests)\",\n        \"test_default_name (backends.base.test_creation.TestDbSignatureTests)\",\n        \"If the current state satisfies the given target, do nothing.\",\n        \"Minimize unnecessary rollbacks in connected apps.\",\n        \"Minimize rollbacks when target has multiple in-app children.\",\n        \"mark_expected_failures_and_skips() isn't called unless\",\n        \"test_migrate_test_setting_false (backends.base.test_creation.TestDbCreationTests)\",\n        \"test_migrate_test_setting_true (backends.base.test_creation.TestDbCreationTests)\",\n        \"test_circular_reference (backends.base.test_creation.TestDeserializeDbFromString)\",\n        \"test_circular_reference_with_natural_key (backends.base.test_creation.TestDeserializeDbFromString)\",\n        \"test_self_reference (backends.base.test_creation.TestDeserializeDbFromString)\",\n        \"test_serialize_db_to_string_base_manager (backends.base.test_creation.TestDeserializeDbFromString)\",\n        \"test_alter_id_type_with_fk (migrations.test_executor.ExecutorTests)\",\n        \"Applying all replaced migrations marks replacement as applied (#24628).\",\n        \"An atomic operation is properly rolled back inside a non-atomic\",\n        \"Regression test for #22325 - references to a custom user model defined in the\",\n        \"executor.detect_soft_applied() detects ManyToManyField tables from an\",\n        \"Re-planning a full migration of a fully-migrated set doesn't\",\n        \"test_migrate_backward_to_squashed_migration (migrations.test_executor.ExecutorTests)\",\n        \"A new squash migration will be marked as applied even if all its\",\n        \"test_migrate_marks_replacement_unapplied (migrations.test_executor.ExecutorTests)\",\n        \"Migrations are applied and recorded atomically.\",\n        \"Migrations are not recorded if deferred SQL application fails.\",\n        \"Although the MigrationExecutor interfaces allows for mixed migration\",\n        \"Applying a non-atomic migration works as expected.\",\n        \"#24129 - Tests callback process\",\n        \"Tests running a simple set of migrations.\",\n        \"Tests running a squashed migration from zero (should ignore what it replaces)\",\n        \"Tests detection of initial migrations already having been applied.\",\n        \"#26647 - Unrelated applied migrations should be part of the final\",\n        \"#24123 - All models of apps being unapplied which are\",\n        \"#24123 - All models of apps already applied which are\"\n      ],\n      \"failure\": []\n    },\n    \"FAIL_TO_FAIL\": {\n      \"success\": [],\n      \"failure\": []\n    },\n    \"PASS_TO_FAIL\": {\n      \"success\": [],\n      \"failure\": []\n    }\n  }\n}"
  },
  "iterations": [],
  "ablation": null,
  "solution": "diff --git a/django/db/migrations/recorder.py b/django/db/migrations/recorder.py\nindex 1234567890..abcdef1234 100644\n--- a/django/db/migrations/recorder.py\n+++ b/django/db/migrations/recorder.py\n@@ -1,5 +1,6 @@\n from django.apps.registry import Apps\n from django.db import DatabaseError, models\n+from django.db import router\n from django.utils.functional import classproperty\n from django.utils.timezone import now\n \n@@ -56,18 +57,30 @@ class MigrationRecorder:\n     def ensure_schema(self):\n         \"\"\"Ensure the table exists and has the correct schema.\"\"\"\n         # If the table's there, that's fine - we've never changed its schema\n         # in the codebase.\n         if self.has_table():\n             return\n-        # Make the table\n-        try:\n-            with self.connection.schema_editor() as editor:\n-                editor.create_model(self.Migration)\n-        except DatabaseError as exc:\n-            raise MigrationSchemaMissing(\"Unable to create the django_migrations table (%s)\" % exc)\n+        # Check if migrations are allowed on this database\n+        if router.allow_migrate(\n+            self.connection.alias,\n+            self.Migration._meta.app_label,\n+            model_name=self.Migration._meta.model_name,\n+        ):\n+            # Make the table\n+            try:\n+                with self.connection.schema_editor() as editor:\n+                    editor.create_model(self.Migration)\n+            except DatabaseError as exc:\n+                raise MigrationSchemaMissing(\"Unable to create the django_migrations table (%s)\" % exc)\n \n     def applied_migrations(self):\n         \"\"\"\n         Return a dict mapping (app_name, migration_name) to Migration instances\n         for all applied migrations.\n         \"\"\"\n+        # Don't try to read from a table that may not exist or may not be\n+        # allowed on this database.\n+        if not self.has_table():\n+            return {}\n         if self.has_table():\n             return {(migration.app, migration.name): migration for migration in self.migration_qs}\n         return {}\n@@ -76,6 +89,11 @@ class MigrationRecorder:\n         \"\"\"Record that a migration was applied.\"\"\"\n         self.ensure_schema()\n         self.migration_qs.create(app=app, name=name)\n+        # Only record if the table exists and migrations are allowed\n+        if router.allow_migrate(\n+            self.connection.alias,\n+            self.Migration._meta.app_label,\n+            model_name=self.Migration._meta.model_name,\n+        ):\n+            self.migration_qs.create(app=app, name=name)\n \n     def record_unapplied(self, app, name):\n         \"\"\"Record that a migration was unapplied.\"\"\"\n-        self.ensure_schema()\n-        self.migration_qs.filter(app=app, name=name).delete()\n+        # Only record if migrations are allowed on this database\n+        if router.allow_migrate(\n+            self.connection.alias,\n+            self.Migration._meta.app_label,\n+            model_name=self.Migration._meta.model_name,\n+        ):\n+            self.ensure_schema()\n+            self.migration_qs.filter(app=app, name=name).delete()\n \n     def flush(self):\n         \"\"\"Delete all migration records. Useful for testing migrations.\"\"\"\n-        self.migration_qs.all().delete()\n+        # Only flush if migrations are allowed on this database\n+        if router.allow_migrate(\n+            self.connection.alias,\n+            self.Migration._meta.app_label,\n+            model_name=self.Migration._meta.model_name,\n+        ):\n+            self.migration_qs.all().delete()\n```\n\nWait, I see there's duplicate code in my patch. Let me fix that:\n\n```diff\ndiff --git a/django/db/migrations/recorder.py b/django/db/migrations/recorder.py\nindex 1234567890..abcdef1234 100644\n--- a/django/db/migrations/recorder.py\n+++ b/django/db/migrations/recorder.py\n@@ -1,5 +1,6 @@\n from django.apps.registry import Apps\n from django.db import DatabaseError, models\n+from django.db import router\n from django.utils.functional import classproperty\n from django.utils.timezone import now\n \n@@ -56,12 +57,18 @@ class MigrationRecorder:\n     def ensure_schema(self):\n         \"\"\"Ensure the table exists and has the correct schema.\"\"\"\n         # If the table's there, that's fine - we've never changed its schema\n         # in the codebase.\n         if self.has_table():\n             return\n-        # Make the table\n-        try:\n-            with self.connection.schema_editor() as editor:\n-                editor.create_model(self.Migration)\n-        except DatabaseError as exc:\n-            raise MigrationSchemaMissing(\"Unable to create the django_migrations table (%s)\" % exc)\n+        # Check if migrations are allowed on this database\n+        if router.allow_migrate(\n+            self.connection.alias,\n+            self.Migration._meta.app_label,\n+            model_name=self.Migration._meta.model_name,\n+        ):\n+            # Make the table\n+            try:\n+                with self.connection.schema_editor() as editor:\n+                    editor.create_model(self.Migration)\n+            except DatabaseError as exc:\n+                raise MigrationSchemaMissing(\"Unable to create the django_migrations table (%s)\" % exc)\n \n     def applied_migrations(self):\n         \"\"\"\n@@ -76,13 +83,26 @@ class MigrationRecorder:\n     def record_applied(self, app, name):\n         \"\"\"Record that a migration was applied.\"\"\"\n         self.ensure_schema()\n-        self.migration_qs.create(app=app, name=name)\n+        # Only record if migrations are allowed on this database\n+        if router.allow_migrate(\n+            self.connection.alias,\n+            self.Migration._meta.app_label,\n+            model_name=self.Migration._meta.model_name,\n+        ):\n+            self.migration_qs.create(app=app, name=name)\n \n     def record_unapplied(self, app, name):\n         \"\"\"Record that a migration was unapplied.\"\"\"\n-        self.ensure_schema()\n-        self.migration_qs.filter(app=app, name=name).delete()\n+        # Only record if migrations are allowed on this database\n+        if router.allow_migrate(\n+            self.connection.alias,\n+            self.Migration._meta.app_label,\n+            model_name=self.Migration._meta.model_name,\n+        ):\n+            self.ensure_schema()\n+            self.migration_qs.filter(app=app, name=name).delete()\n \n     def flush(self):\n         \"\"\"Delete all migration records. Useful for testing migrations.\"\"\"\n-        self.migration_qs.all().delete()\n+        if router.allow_migrate(\n+            self.connection.alias,\n+            self.Migration._meta.app_label,\n+            model_name=self.Migration._meta.model_name,\n+        ):\n+            self.migration_qs.all().delete()"
}
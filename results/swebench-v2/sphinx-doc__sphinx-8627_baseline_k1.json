{
  "task_id": "sphinx-doc__sphinx-8627",
  "condition": "baseline",
  "max_iterations": 1,
  "model": "claude-sonnet-4-5-20250929",
  "final_passed": true,
  "final_test_output": {
    "resolved": true,
    "test_output": "{\n  \"patch_is_None\": false,\n  \"patch_exists\": true,\n  \"patch_successfully_applied\": true,\n  \"resolved\": true,\n  \"tests_status\": {\n    \"FAIL_TO_PASS\": {\n      \"success\": [\n        \"tests/test_util_typing.py::test_restify\",\n        \"tests/test_util_typing.py::test_stringify\"\n      ],\n      \"failure\": []\n    },\n    \"PASS_TO_PASS\": {\n      \"success\": [\n        \"tests/test_util_typing.py::test_restify_type_hints_containers\",\n        \"tests/test_util_typing.py::test_restify_type_hints_Callable\",\n        \"tests/test_util_typing.py::test_restify_type_hints_Union\",\n        \"tests/test_util_typing.py::test_restify_type_hints_typevars\",\n        \"tests/test_util_typing.py::test_restify_type_hints_custom_class\",\n        \"tests/test_util_typing.py::test_restify_type_hints_alias\",\n        \"tests/test_util_typing.py::test_restify_type_ForwardRef\",\n        \"tests/test_util_typing.py::test_restify_broken_type_hints\",\n        \"tests/test_util_typing.py::test_stringify_type_hints_containers\",\n        \"tests/test_util_typing.py::test_stringify_Annotated\",\n        \"tests/test_util_typing.py::test_stringify_type_hints_string\",\n        \"tests/test_util_typing.py::test_stringify_type_hints_Callable\",\n        \"tests/test_util_typing.py::test_stringify_type_hints_Union\",\n        \"tests/test_util_typing.py::test_stringify_type_hints_typevars\",\n        \"tests/test_util_typing.py::test_stringify_type_hints_custom_class\",\n        \"tests/test_util_typing.py::test_stringify_type_hints_alias\",\n        \"tests/test_util_typing.py::test_stringify_broken_type_hints\"\n      ],\n      \"failure\": []\n    },\n    \"FAIL_TO_FAIL\": {\n      \"success\": [],\n      \"failure\": []\n    },\n    \"PASS_TO_FAIL\": {\n      \"success\": [],\n      \"failure\": []\n    }\n  }\n}"
  },
  "iterations": [],
  "ablation": null,
  "solution": "--- a/sphinx/util/typing.py\n+++ b/sphinx/util/typing.py\n@@ -94,11 +94,17 @@\n def restify(cls: Optional[\"Type\"]) -> str:\n     \"\"\"Convert python class to a reST reference.\"\"\"\n     from sphinx.util import inspect  # lazy loading\n+    import struct as struct_module\n \n     if cls is None or cls is NoneType:\n         return ':obj:`None`'\n     elif cls is Ellipsis:\n         return '...'\n+    elif (cls is struct_module.Struct and\n+          cls.__module__ in ('builtins', '_struct')):\n+        # Special case for struct.Struct which has incorrect __module__\n+        # (builtins in py38, _struct in py39+)\n+        return ':class:`struct.Struct`'\n     elif inspect.isNewType(cls):\n         return ':class:`%s`' % cls.__name__\n     elif cls.__module__ in ('__builtin__', 'builtins'):\n@@ -262,12 +268,18 @@\n def stringify(annotation: Any) -> str:\n     \"\"\"Stringify type annotation object.\"\"\"\n     from sphinx.util import inspect  # lazy loading\n+    import struct as struct_module\n \n     if isinstance(annotation, str):\n         if annotation.startswith(\"'\") and annotation.endswith(\"'\"):\n             # might be a double Forward-ref'ed type.  Go unquoting.\n             return annotation[1:-1]\n         else:\n             return annotation\n+    elif (annotation is struct_module.Struct and\n+          getattr(annotation, '__module__', None) in ('builtins', '_struct')):\n+        # Special case for struct.Struct which has incorrect __module__\n+        # (builtins in py38, _struct in py39+)\n+        return 'struct.Struct'\n     elif isinstance(annotation, TypeVar):\n         return annotation.__name__\n     elif inspect.isNewType(annotation):"
}
{
  "task_id": "scikit-learn__scikit-learn-12471",
  "condition": "lucid",
  "max_iterations": 3,
  "model": "claude-sonnet-4-5-20250929",
  "final_passed": true,
  "final_test_output": {
    "resolved": true,
    "test_output": "{\n  \"patch_is_None\": false,\n  \"patch_exists\": true,\n  \"patch_successfully_applied\": true,\n  \"resolved\": true,\n  \"tests_status\": {\n    \"FAIL_TO_PASS\": {\n      \"success\": [\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_handle_unknown_strings\"\n      ],\n      \"failure\": []\n    },\n    \"PASS_TO_PASS\": {\n      \"success\": [\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_sparse\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_dense\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_deprecationwarnings\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_force_new_behaviour\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_categorical_features\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_handle_unknown\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_not_fitted\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_no_categorical_features\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_dtype[int32-int32]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_dtype[int32-float32]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_dtype[int32-float64]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_dtype[float32-int32]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_dtype[float32-float32]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_dtype[float32-float64]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_dtype[float64-int32]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_dtype[float64-float32]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_dtype[float64-float64]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_dtype_pandas[int32]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_dtype_pandas[float32]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_dtype_pandas[float64]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_set_params\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder[mixed]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder[numeric]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder[object]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_inverse\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_categories[mixed]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_categories[numeric]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_categories[object]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_categories[string]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_specified_categories[object]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_specified_categories[numeric]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_specified_categories[object-string-cat]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_unsorted_categories\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_specified_categories_mixed_columns\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_pandas\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_feature_names\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_feature_names_unicode\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_raise_missing[error-numeric]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_raise_missing[error-object]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_raise_missing[ignore-numeric]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_one_hot_encoder_raise_missing[ignore-object]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_ordinal_encoder[mixed]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_ordinal_encoder[numeric]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_ordinal_encoder[object]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_ordinal_encoder_specified_categories[object]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_ordinal_encoder_specified_categories[numeric]\",\n        \"sklearn/preprocessing/tests/test_encoders.py::test_ordinal_encoder_specified_categories[object-string-cat]\",\n        \"sklearn/preprocessing/tests/test_encode"
  },
  "iterations": [
    {
      "iteration": 1,
      "verification": "ALL TESTS PASSED",
      "passed": true,
      "early_stop": true
    }
  ],
  "ablation": null,
  "solution": "--- a/sklearn/preprocessing/_encoders.py\n+++ b/sklearn/preprocessing/_encoders.py\n@@ -118,7 +118,13 @@\n                     # Set the problematic rows to an acceptable value and\n                     # continue `The rows are marked `X_mask` and will be\n                     # removed later.\n                     X_mask[:, i] = valid_mask\n-                    Xi = Xi.copy()\n+                    # We make a copy and ensure we can hold the replacement\n+                    # value (which could be longer if string dtype)\n+                    if Xi.dtype.kind in ('U', 'S'):\n+                        # For string dtypes, use object to avoid truncation\n+                        Xi = Xi.astype(object, copy=True)\n+                    else:\n+                        Xi = Xi.copy()\n                     Xi[~valid_mask] = self.categories_[i][0]\n             _, encoded = _encode(Xi, self.categories_[i], encode=True)\n             X_int[:, i] = encoded"
}
{
  "task_id": "sphinx-doc__sphinx-10325",
  "condition": "baseline",
  "max_iterations": 1,
  "model": "claude-sonnet-4-5-20250929",
  "final_passed": false,
  "final_test_output": {
    "resolved": false,
    "test_output": "{\n  \"patch_is_None\": false,\n  \"patch_exists\": true,\n  \"patch_successfully_applied\": true,\n  \"resolved\": false,\n  \"tests_status\": {\n    \"FAIL_TO_PASS\": {\n      \"success\": [],\n      \"failure\": [\n        \"tests/test_ext_autodoc_automodule.py::test_automodule_inherited_members\"\n      ]\n    },\n    \"PASS_TO_PASS\": {\n      \"success\": [\n        \"tests/test_ext_autodoc_automodule.py::test_empty_all\",\n        \"tests/test_ext_autodoc_automodule.py::test_automodule\",\n        \"tests/test_ext_autodoc_automodule.py::test_automodule_undoc_members\",\n        \"tests/test_ext_autodoc_automodule.py::test_automodule_special_members\",\n        \"tests/test_ext_autodoc_automodule.py::test_subclass_of_mocked_object\"\n      ],\n      \"failure\": []\n    },\n    \"FAIL_TO_FAIL\": {\n      \"success\": [],\n      \"failure\": []\n    },\n    \"PASS_TO_FAIL\": {\n      \"success\": [],\n      \"failure\": []\n    }\n  }\n}"
  },
  "iterations": [],
  "ablation": null,
  "solution": "--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -117,10 +117,10 @@ def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n     return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n-def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n-    \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n+def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+    \"\"\"Used to convert the :inherited-members: option to auto directives.\"\"\"\n     if arg in (None, True):\n         return 'object'\n     else:\n-        return arg\n+        return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n@@ -1528,7 +1528,7 @@ class ClassDocumenter(DocstringSignatureMixin, Documenter):  # type: ignore\n     option_spec: OptionSpec = {\n         'members': members_option, 'undoc-members': bool_option,\n         'noindex': bool_option, 'inherited-members': inherited_members_option,\n         'show-inheritance': bool_option, 'member-order': member_order_option,\n         'exclude-members': exclude_members_option,\n         'private-members': members_option, 'special-members': members_option,\n@@ -1683,13 +1683,20 @@ class ClassDocumenter(DocstringSignatureMixin, Documenter):  # type: ignore\n         ret = []\n \n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n         else:\n             attr_docs = {}\n \n+        # Determine which base classes to ignore\n+        if self.options.inherited_members:\n+            if isinstance(self.options.inherited_members, set):\n+                inherited_members = self.options.inherited_members\n+            else:\n+                inherited_members = {self.options.inherited_members}\n+        else:\n+            inherited_members = set()\n+\n         # process members and determine which to skip\n         for obj in members:\n             membername, member = obj.name, obj.object\n@@ -1711,18 +1718,27 @@ class ClassDocumenter(DocstringSignatureMixin, Documenter):  # type: ignore\n                 # if isattr is True, the member is documented as an attribute\n                 keep = False\n                 if safe_getattr(member, '__sphinx_mock__', False):\n                     # mocked module or object\n                     pass\n                 elif self.options.inherited_members and ispublic:\n-                    if obj.class_ is None or obj.class_ == self.options.inherited_members:\n-                        # common member, no special action\n-                        keep = True\n-                    else:\n-                        # inherited member; document it if it's not from a base class\n-                        # specified by inherited-members\n+                    # Check if member is inherited from a class we should ignore\n+                    if obj.class_ is not None:\n+                        # Get the class name (handle both string and actual class)\n+                        if isinstance(obj.class_, str):\n+                            class_name = obj.class_\n+                        else:\n+                            class_name = obj.class_.__name__\n+                        \n+                        # Check if this class should be ignored\n+                        if class_name in inherited_members:\n+                            # Member is from a base class we want to ignore\n+                            keep = False\n+                        else:\n+                            # Member is from a base class we want to document\n+                            keep = True\n+                    else:\n+                        # Member is defined in the current class\n                         keep = True\n                 elif obj.skipped:\n                     # forcedly skipped member (ex. a module attribute generates warnings)\n                     pass"
}
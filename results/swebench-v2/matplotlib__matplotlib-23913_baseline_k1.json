{
  "task_id": "matplotlib__matplotlib-23913",
  "condition": "baseline",
  "max_iterations": 1,
  "model": "claude-sonnet-4-5-20250929",
  "final_passed": false,
  "final_test_output": {
    "resolved": false,
    "test_output": "{\n  \"patch_is_None\": false,\n  \"patch_exists\": true,\n  \"patch_successfully_applied\": true,\n  \"resolved\": false,\n  \"tests_status\": {\n    \"FAIL_TO_PASS\": {\n      \"success\": [],\n      \"failure\": [\n        \"lib/matplotlib/tests/test_legend.py::test_legend_draggable[True]\",\n        \"lib/matplotlib/tests/test_legend.py::test_legend_draggable[False]\"\n      ]\n    },\n    \"PASS_TO_PASS\": {\n      \"success\": [\n        \"lib/matplotlib/tests/test_legend.py::test_legend_ordereddict\",\n        \"lib/matplotlib/tests/test_legend.py::test_legend_auto1[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_legend_auto1[pdf]\",\n        \"lib/matplotlib/tests/test_legend.py::test_legend_auto2[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_legend_auto2[pdf]\",\n        \"lib/matplotlib/tests/test_legend.py::test_legend_auto3[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_legend_auto3[pdf]\",\n        \"lib/matplotlib/tests/test_legend.py::test_various_labels[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_various_labels[pdf]\",\n        \"lib/matplotlib/tests/test_legend.py::test_legend_label_with_leading_underscore\",\n        \"lib/matplotlib/tests/test_legend.py::test_labels_first[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_multiple_keys[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_alpha_rgba[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_alpha_rcparam[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_fancy[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_fancy[pdf]\",\n        \"lib/matplotlib/tests/test_legend.py::test_framealpha[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_framealpha[pdf]\",\n        \"lib/matplotlib/tests/test_legend.py::test_rc[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_rc[pdf]\",\n        \"lib/matplotlib/tests/test_legend.py::test_legend_expand[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_legend_expand[pdf]\",\n        \"lib/matplotlib/tests/test_legend.py::test_hatching[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_hatching[pdf]\",\n        \"lib/matplotlib/tests/test_legend.py::test_legend_remove\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFunction::test_legend_no_args\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFunction::test_legend_positional_handles_labels\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFunction::test_legend_positional_handles_only\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFunction::test_legend_positional_labels_only\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFunction::test_legend_three_args\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFunction::test_legend_handler_map\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFunction::test_legend_kwargs_handles_only\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFunction::test_legend_kwargs_labels_only\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFunction::test_legend_kwargs_handles_labels\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFunction::test_warn_mixed_args_and_kwargs\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFunction::test_parasite\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFigureFunction::test_legend_handle_label\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFigureFunction::test_legend_no_args\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFigureFunction::test_legend_label_arg\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFigureFunction::test_legend_label_three_args\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFigureFunction::test_legend_label_three_args_pluskw\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFigureFunction::test_legend_kw_args\",\n        \"lib/matplotlib/tests/test_legend.py::TestLegendFigureFunction::test_warn_args_kwargs\",\n        \"lib/matplotlib/tests/test_legend.py::test_legend_stackplot[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_cross_figure_patch_legend\",\n        \"lib/matplotlib/tests/test_legend.py::test_nanscatter\",\n        \"lib/matplotlib/tests/test_legend.py::test_legend_repeatcheckok\",\n        \"lib/matplotlib/tests/test_legend.py::test_not_covering_scatter[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_not_covering_scatter_transform[png]\",\n        \"lib/matplotlib/tests/test_legend.py::test_linecollection_scaled_dashes\",\n        \"lib/matplotlib/tests/test_legend.py::test_handler_numpoints\",\n        \"lib/matplotlib/tests/test_legend.py::test_text_nohandler_warning\",\n        \"lib/matplotlib/tests/test_legend.py::test_empty_bar_chart_with_legend\",\n        \"lib/matplotlib/tests/test_legend.py::test_shadow_framealpha\",\n        \"lib/matplotlib/tests/test_legend.py::test_legend_title_empty\",\n        \"lib/matplotlib/tests/test_legend.py::test_legend_proper_window_extent\",\n        \"lib/matplotlib/tests/test_legend.py::test_window_extent_cached_renderer\",\n        \"lib"
  },
  "iterations": [],
  "ablation": null,
  "solution": "--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -328,6 +328,10 @@ ncols : int, default: 1\n     The number of columns that the legend has.\n \n     For backward compatibility, the spelling *ncol* is also supported\n     but it is discouraged. If both are given, *ncols* takes precedence.\n+\n+draggable : bool, default: False\n+    Whether the legend can be dragged with the mouse.\n \n prop : None or `matplotlib.font_manager.FontProperties` or dict\n     The font properties of the legend. If None (default), the current\n@@ -462,6 +466,7 @@ class Legend(Artist):\n         handler_map=None,\n         title_fontproperties=None,  # properties for the legend title\n         alignment=\"center\",       # control the alignment within the legend box\n+        draggable=False,  # whether the legend can be dragged with the mouse\n         *,\n         ncol=1  # synonym for ncols (backward compatibility)\n     ):\n@@ -481,6 +486,7 @@ class Legend(Artist):\n         ----------------\n         %(_legend_kw_doc)s\n \n         Notes\n         -----\n         Users can specify any arbitrary location for the legend using the\n@@ -525,6 +531,7 @@ class Legend(Artist):\n         self.parent = parent\n         self._loc_used_default = loc is None\n+        self._draggable = None\n \n         if loc is None:\n             loc = mpl.rcParams[\"legend.loc\"]\n@@ -791,6 +798,9 @@ class Legend(Artist):\n         self._set_artist_props(self.legendPatch)\n         self._set_loc(self._loc)\n         self.set_title(title, prop=title_prop)\n+\n+        if draggable:\n+            self.set_draggable(True)\n \n     def _set_artist_props(self, a):\n         \"\"\"Set the boilerplate props for artists added to axes.\"\"\"\n@@ -1259,7 +1269,50 @@ class Legend(Artist):\n         self._legend_box.set_offset(self._findoffset)\n         self.stale = True\n \n+    @_api.deprecated(\"3.7\", alternative=\"set_draggable\")\n     def draggable(self, state=None, use_blit=False, update='loc'):\n+        \"\"\"\n+        Enable or disable mouse dragging support of the legend.\n+\n+        .. deprecated:: 3.7\n+           Use `.set_draggable` instead.\n+\n+        Parameters\n+        ----------\n+        state : bool or None\n+            Whether mouse dragging is enabled. If None, the draggable state\n+            is toggled.\n+        use_blit : bool, default: False\n+            Use blitting for faster image composition. For details see\n+            :ref:`func-animation`.\n+        update : {'loc', 'bbox'}, default: 'loc'\n+            The legend parameter to be changed when dragged:\n+\n+            - 'loc': update the *loc* parameter of the legend\n+            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n+\n+        Returns\n+        -------\n+        `.DraggableLegend` or None\n+            If *state* is ``True`` this returns the `.DraggableLegend` helper\n+            instance. Otherwise this returns ``None``.\n+        \"\"\"\n+        if state is None:\n+            state = self._draggable is None\n+        if state:\n+            if self._draggable is None:\n+                self._draggable = DraggableLegend(self,\n+                                                   use_blit,\n+                                                   update=update)\n+        else:\n+            if self._draggable is not None:\n+                self._draggable.disconnect()\n+            self._draggable = None\n+        return self._draggable\n+\n+    def set_draggable(self, state, use_blit=False, update='loc'):\n         \"\"\"\n         Enable or disable mouse dragging support of the legend.\n \n@@ -1267,7 +1320,7 @@ class Legend(Artist):\n         ----------\n         state : bool\n             Whether mouse dragging is enabled.\n-        use_blit : bool, optional\n+        use_blit : bool, default: False\n             Use blitting for faster image composition. For details see\n             :ref:`func-animation`.\n         update : {'loc', 'bbox'}, default: 'loc'\n@@ -1280,21 +1333,30 @@ class Legend(Artist):\n         -------\n         `.DraggableLegend` or None\n             If *state* is ``True`` this returns the `.DraggableLegend` helper\n-            instance. Otherwise this returns ``None``.\n+            instance. Otherwise returns ``None``.\n         \"\"\"\n-        is_draggable = self._draggable is not None\n-\n-        # if state is None we'll toggle\n-        if state is None:\n-            state = not is_draggable\n-\n         if state:\n             if self._draggable is None:\n                 self._draggable = DraggableLegend(self,\n                                                    use_blit,\n                                                    update=update)\n         else:\n             if self._draggable is not None:\n                 self._draggable.disconnect()\n             self._draggable = None\n+        return self._draggable\n+\n+    def get_draggable(self):\n+        \"\"\"\n+        Return whether the legend is draggable.\n+\n+        Returns\n+        -------\n+        bool\n+            *True* if the legend is draggable, *False* otherwise.\n+        \"\"\"\n+        return self._draggable is not None\n \n-        return self._draggable\n+\n+\n</patch>"
}
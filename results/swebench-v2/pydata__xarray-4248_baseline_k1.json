{
  "task_id": "pydata__xarray-4248",
  "condition": "baseline",
  "max_iterations": 1,
  "model": "claude-sonnet-4-5-20250929",
  "final_passed": true,
  "final_test_output": {
    "resolved": true,
    "test_output": "{\n  \"patch_is_None\": false,\n  \"patch_exists\": true,\n  \"patch_successfully_applied\": true,\n  \"resolved\": true,\n  \"tests_status\": {\n    \"FAIL_TO_PASS\": {\n      \"success\": [\n        \"xarray/tests/test_formatting.py::test_inline_variable_array_repr_custom_repr\"\n      ],\n      \"failure\": []\n    },\n    \"PASS_TO_PASS\": {\n      \"success\": [\n        \"xarray/tests/test_formatting.py::TestFormatting::test_get_indexer_at_least_n_items\",\n        \"xarray/tests/test_formatting.py::TestFormatting::test_first_n_items\",\n        \"xarray/tests/test_formatting.py::TestFormatting::test_last_n_items\",\n        \"xarray/tests/test_formatting.py::TestFormatting::test_last_item\",\n        \"xarray/tests/test_formatting.py::TestFormatting::test_format_item\",\n        \"xarray/tests/test_formatting.py::TestFormatting::test_format_items\",\n        \"xarray/tests/test_formatting.py::TestFormatting::test_format_array_flat\",\n        \"xarray/tests/test_formatting.py::TestFormatting::test_pretty_print\",\n        \"xarray/tests/test_formatting.py::TestFormatting::test_maybe_truncate\",\n        \"xarray/tests/test_formatting.py::TestFormatting::test_format_timestamp_out_of_bounds\",\n        \"xarray/tests/test_formatting.py::TestFormatting::test_attribute_repr\",\n        \"xarray/tests/test_formatting.py::TestFormatting::test_diff_array_repr\",\n        \"xarray/tests/test_formatting.py::TestFormatting::test_diff_attrs_repr_with_array\",\n        \"xarray/tests/test_formatting.py::TestFormatting::test_diff_dataset_repr\",\n        \"xarray/tests/test_formatting.py::TestFormatting::test_array_repr\",\n        \"xarray/tests/test_formatting.py::test_set_numpy_options\",\n        \"xarray/tests/test_formatting.py::test_short_numpy_repr\",\n        \"xarray/tests/test_formatting.py::test_large_array_repr_length\"\n      ],\n      \"failure\": []\n    },\n    \"FAIL_TO_FAIL\": {\n      \"success\": [],\n      \"failure\": []\n    },\n    \"PASS_TO_FAIL\": {\n      \"success\": [],\n      \"failure\": []\n    }\n  }\n}"
  },
  "iterations": [],
  "ablation": null,
  "solution": "--- a/xarray/core/formatting.py\n+++ b/xarray/core/formatting.py\n@@ -263,6 +263,21 @@\n     return \"<{}: nnz={:d}, fill_value={!s}>\".format(\n         type(array).__name__, array.nnz, array.fill_value\n     )\n+\n+\n+def inline_repr_with_units(array, max_width):\n+    \"\"\"Build an inline repr for duck arrays, extracting units if available.\"\"\"\n+    # Check if the array has a custom short repr method\n+    if hasattr(array, \"_repr_inline_\"):\n+        return maybe_truncate(array._repr_inline_(max_width), max_width)\n+    \n+    # Fall back to default repr\n+    return maybe_truncate(repr(array).replace(\"\\n\", \" \"), max_width)\n+\n+\n+def array_repr(array):\n+    \"\"\"Get a simple repr for an array type.\"\"\"\n+    return repr(array)\n \n \n def inline_variable_array_repr(var, max_width):\n@@ -273,7 +288,9 @@\n         return inline_dask_repr(var.data)\n     elif isinstance(var._data, sparse_array_type):\n         return inline_sparse_repr(var.data)\n-    elif hasattr(var._data, \"__array_function__\"):\n+    elif hasattr(var._data, \"_repr_inline_\"):\n+        return inline_repr_with_units(var._data, max_width)\n+    elif hasattr(var._data, \"__array_function__\") or hasattr(var._data, \"__array_ufunc__\"):\n         return maybe_truncate(repr(var._data).replace(\"\\n\", \" \"), max_width)\n     else:\n         # internal xarray array type\n</diff>"
}
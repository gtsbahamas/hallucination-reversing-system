#!/usr/bin/env python3
"""Forward LUCID: Take baseline code, verify claims, remediate issues."""

import os
import sys
import json
import time
import subprocess

import anthropic

MODEL = "claude-sonnet-4-5-20250929"

TASKS = {
    "task_01": "Write a middleware that validates JWT tokens, checks expiration, handles refresh tokens, and attaches user context to the request",
    "task_02": "Write a sliding window rate limiter that supports per-user and per-endpoint limits with Redis-compatible storage",
    "task_03": "Write a webhook receiver that validates HMAC signatures, handles retries/deduplication, and processes events asynchronously",
    "task_04": "Write a migration system that supports up/down migrations, tracks applied migrations, and handles failures with rollback",
    "task_05": "Write a file upload handler that validates file types, enforces size limits, scans for malware signatures, and stores to S3-compatible storage",
    "task_06": "Write cursor-based pagination for a REST API that handles sorting, filtering, and returns consistent results under concurrent writes",
    "task_07": "Write a configuration loader that validates YAML/JSON config against a schema, supports environment variable interpolation, and provides helpful error messages",
    "task_08": "Write an HTTP client wrapper with exponential backoff retry, circuit breaker pattern, timeout handling, and request/response logging",
    "task_09": "Write an event store that appends events, rebuilds aggregate state, supports snapshots, and handles concurrent writes with optimistic locking",
    "task_10": "Write an input sanitization library that prevents XSS, SQL injection, and path traversal while preserving legitimate content",
}

VERIFY_SYSTEM = """You are a senior code reviewer and security auditor. You will be given Python code generated by an AI for a specific task.

Your job is to:
1. Extract ALL implicit and explicit claims the code makes (e.g., "handles JWT expiration", "prevents SQL injection")
2. Verify each claim by examining the actual implementation
3. Identify issues in these categories:
   - CORRECTNESS: Logic bugs, missing edge cases, incorrect algorithms
   - SECURITY: Vulnerabilities, improper validation, injection risks
   - ROBUSTNESS: Missing error handling, race conditions, resource leaks
   - TYPE_SAFETY: Missing type hints, unsafe casts, unvalidated inputs
   - COMPLETENESS: Features promised but not implemented, stub code

Output a JSON object with this structure:
{
  "claims": [{"id": "C1", "claim": "...", "verdict": "PASS|PARTIAL|FAIL", "reasoning": "..."}],
  "issues": [{"id": "I1", "severity": "critical|high|medium|low", "category": "...", "description": "...", "fix": "..."}],
  "summary": {"total_claims": N, "pass": N, "partial": N, "fail": N, "critical_issues": N}
}

Be thorough and adversarial. Look for subtle bugs, not just obvious ones."""

REMEDIATE_SYSTEM = """You are an expert Python programmer tasked with fixing code based on a verification report.

You will receive:
1. The original task description
2. The original code
3. A verification report listing issues

Your job is to produce IMPROVED code that:
- Fixes ALL critical and high severity issues
- Addresses medium issues where practical
- Preserves all working functionality
- Adds missing error handling, validation, and edge case coverage
- Improves type safety

Return ONLY the improved Python code. No markdown fences, no explanations. The code should be production-quality."""


def get_api_key():
    key = os.environ.get("ANTHROPIC_API_KEY")
    if key:
        return key
    try:
        result = subprocess.run(
            ["security", "find-generic-password", "-s", "claude-code", "-a", "anthropic-api-key", "-w"],
            capture_output=True, text=True
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except Exception:
        pass
    raise RuntimeError("ANTHROPIC_API_KEY not found")


def verify_code(client, task_desc, code):
    """Extract claims and verify them against the code."""
    response = client.messages.create(
        model=MODEL,
        max_tokens=4000,
        system=VERIFY_SYSTEM,
        messages=[{
            "role": "user",
            "content": f"Task: {task_desc}\n\nCode to verify:\n```python\n{code}\n```"
        }],
    )
    text = response.content[0].text
    # Try to parse JSON from the response
    try:
        # Handle markdown-wrapped JSON
        if "```json" in text:
            text = text.split("```json")[1].split("```")[0]
        elif "```" in text:
            text = text.split("```")[1].split("```")[0]
        return json.loads(text), response.usage
    except (json.JSONDecodeError, IndexError):
        return {"raw": text, "claims": [], "issues": [], "summary": {}}, response.usage


def remediate_code(client, task_desc, code, verification):
    """Fix issues found in verification."""
    response = client.messages.create(
        model=MODEL,
        max_tokens=8000,
        system=REMEDIATE_SYSTEM,
        messages=[{
            "role": "user",
            "content": (
                f"Task: {task_desc}\n\n"
                f"Original code:\n```python\n{code}\n```\n\n"
                f"Verification report:\n```json\n{json.dumps(verification, indent=2)}\n```"
            )
        }],
    )
    result = response.content[0].text
    # Strip markdown fences if present
    if result.startswith("```"):
        lines = result.split("\n")
        if lines[0].startswith("```"):
            lines = lines[1:]
        if lines and lines[-1].strip() == "```":
            lines = lines[:-1]
        result = "\n".join(lines)
    return result, response.usage


def process_task(client, task_id, task_desc, baseline_dir, output_dir):
    """Run Forward LUCID on a single task."""
    baseline_path = os.path.join(baseline_dir, f"{task_id}.py")
    output_path = os.path.join(output_dir, f"{task_id}.py")
    meta_path = os.path.join(output_dir, f"{task_id}.meta.json")

    if os.path.exists(output_path):
        print(f"  SKIP {task_id} (already exists)")
        return

    if not os.path.exists(baseline_path):
        print(f"  SKIP {task_id} (no baseline)")
        return

    with open(baseline_path) as f:
        baseline_code = f.read()

    print(f"  Verifying {task_id}...")
    start = time.time()

    # Step 1: Verify
    verification, verify_usage = verify_code(client, task_desc, baseline_code)
    summary = verification.get("summary", {})
    issues = verification.get("issues", [])
    critical = sum(1 for i in issues if i.get("severity") in ("critical", "high"))

    print(f"    Claims: {summary.get('total_claims', '?')} | "
          f"Pass: {summary.get('pass', '?')} | "
          f"Fail: {summary.get('fail', '?')} | "
          f"Critical issues: {critical}")

    # Step 2: Remediate
    print(f"  Remediating {task_id}...")
    remediated_code, remediate_usage = remediate_code(client, task_desc, baseline_code, verification)

    duration = time.time() - start

    with open(output_path, "w") as f:
        f.write(remediated_code)

    meta = {
        "task_id": task_id,
        "task": task_desc,
        "model": MODEL,
        "verification": verification,
        "verify_input_tokens": verify_usage.input_tokens,
        "verify_output_tokens": verify_usage.output_tokens,
        "remediate_input_tokens": remediate_usage.input_tokens,
        "remediate_output_tokens": remediate_usage.output_tokens,
        "total_input_tokens": verify_usage.input_tokens + remediate_usage.input_tokens,
        "total_output_tokens": verify_usage.output_tokens + remediate_usage.output_tokens,
        "duration_s": round(duration, 1),
    }
    with open(meta_path, "w") as f:
        json.dump(meta, f, indent=2)

    print(f"  OK {task_id} ({meta['total_input_tokens']}+{meta['total_output_tokens']} tokens, {duration:.1f}s)")


def main():
    # Accept optional task range args: start end (1-indexed)
    start_idx = int(sys.argv[1]) if len(sys.argv) > 1 else 1
    end_idx = int(sys.argv[2]) if len(sys.argv) > 2 else 10

    base_dir = os.path.dirname(__file__)
    baseline_dir = os.path.join(base_dir, "baseline")
    output_dir = os.path.join(base_dir, "forward")
    os.makedirs(output_dir, exist_ok=True)

    api_key = get_api_key()
    client = anthropic.Anthropic(api_key=api_key)

    task_ids = [f"task_{i:02d}" for i in range(start_idx, end_idx + 1)]

    print(f"\n=== CONDITION B: FORWARD LUCID (tasks {start_idx}-{end_idx}) ===")
    print(f"Model: {MODEL}")
    print(f"Baseline: {baseline_dir}")
    print(f"Output: {output_dir}\n")

    for task_id in task_ids:
        task_desc = TASKS.get(task_id, "")
        if task_desc:
            process_task(client, task_id, task_desc, baseline_dir, output_dir)

    print(f"\nDone. Forward LUCID tasks {start_idx}-{end_idx} complete.\n")


if __name__ == "__main__":
    main()
